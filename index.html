<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PEP ‚Äî 3 pain√©is + IA</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <h1>PEP (prot√≥tipo) ‚Äî Entrada | Organiza√ß√£o | An√°lise</h1>
  </header>

  <main>
    <section class="row">
      <div class="col">
        <label>1) Informa√ß√£o crua do atendimento</label>
        <textarea id="entrada" placeholder="Digite ou cole aqui o texto livre da consulta..."></textarea>
      </div>

      <div class="col">
        <label>2) Organiza√ß√£o (SOAP/estruturado)</label>
        <pre id="org">Aguardando...</pre>
      </div>

      <div class="col">
        <label>3) An√°lise cl√≠nica (IA em tempo real)</label>
        <pre id="analise">Aguardando...</pre>
      </div>
    </section>

    <section class="footer">
      <div class="controls">
        <button id="btnExecutar">‚ñ∂Ô∏è Processar</button>
        <button id="btnPausar">‚è∏Ô∏è Pausar</button>
        <button id="btnLimpar">üßπ Limpar</button>
        <label class="small"><input type="checkbox" id="cbAuto" checked /> Processar automaticamente (1s ap√≥s parar de digitar)</label>
      </div>
      <div class="hint">‚ö†Ô∏è Dados sens√≠veis: use exemplos fict√≠cios neste prot√≥tipo.</div>
    </section>
  </main>

  <script>
    const entrada = document.getElementById('entrada');
    const org = document.getElementById('org');
    const analise = document.getElementById('analise');
    const btnExecutar = document.getElementById('btnExecutar');
    const btnPausar = document.getElementById('btnPausar');
    const btnLimpar = document.getElementById('btnLimpar');
    const cbAuto = document.getElementById('cbAuto');

    let abortOrg = null;
    let abortAna = null;
    let timer = null;

    function limpar() {
      org.textContent = 'Aguardando...';
      analise.textContent = 'Aguardando...';
    }

    function pausar() {
      if (abortOrg) { abortOrg.abort(); abortOrg = null; }
      if (abortAna) { abortAna.abort(); abortAna = null; }
    }

    // ... (c√≥digo anterior da script)

    async function streamTo(el, url, payload) {
      el.textContent = '';
      const controller = new AbortController();
      const signal = controller.signal;

      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          signal
        });

        if (!res.ok || !res.body) {
          el.textContent = `Erro do servidor (${res.status}): ${res.statusText}`;
          return { abort: () => controller.abort() };
        }
        
        // A fun√ß√£o n√£o precisa lidar com SSE aqui se o backend fizer o trabalho.
        // Assumindo que o backend est√° re-transmitindo o corpo da resposta bruta (que √© SSE).
        // Se a resposta do backend for SSE (como √© o caso aqui):
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        
        // Vamos extrair o conte√∫do do JSON SSE.
        // NOTA: Esta √© a parte mais cr√≠tica e o c√≥digo original estava incorreto para SSE.
        // Se voc√™ n√£o quer lidar com SSE no frontend, a corre√ß√£o √© mover a l√≥gica 
        // de decodifica√ß√£o de SSE para o backend (API Functions), o que √© MUITO mais robusto.

        // **Op√ß√£o 1 (Melhor): Deixar o Backend Limpar o SSE (Ver Se√ß√£o 2)**
        // Se voc√™ fizer a corre√ß√£o do Backend na Se√ß√£o 2 (Recomendado), a fun√ß√£o pode ser:
        
        (async () => {
          try {
            let fullText = '';
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              
              // O backend CORRIGIDO vai enviar apenas o texto puro.
              fullText += decoder.decode(value, { stream: true });
              el.textContent = fullText; 
            }
          } catch (e) {
            if (e.name !== 'AbortError') {
              el.textContent += `\n[Erro de Stream: ${e.message}]`;
            }
          }
        })();

        return { abort: () => controller.abort() };

      } catch (e) {
        if (e.name !== 'AbortError') {
          el.textContent = `Erro de Conex√£o: ${e.message}`;
        }
        return { abort: () => controller.abort() };
      }
    }

// ... (c√≥digo restante da script)

      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        signal
      });

      if (!res.ok || !res.body) {
        el.textContent = 'Erro ao conectar.';
        return { abort: () => controller.abort() };
      }

      const reader = res.body.getReader();
      const decoder = new TextDecoder();

      (async () => {
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            el.textContent += decoder.decode(value, { stream: true });
          }
        } catch (e) {}
      })();

      return { abort: () => controller.abort() };
    }

    async function processar() {
      pausar();
      const texto = entrada.value.trim();
      if (!texto) return;

      const payloadOrg = {
        input: texto,
        instructions: `Organize o texto cl√≠nico no formato SOAP curto.\n- S: Queixa principal e HMA em t√≥picos\n- O: Sinais vitais, achados relevantes\n- A: Hip√≥teses com CID-10 se fornecido\n- P: Condutas iniciais\nN√£o invente dados.`
      };
      const payloadAna = {
        input: texto,
        instructions: `Avalie coer√™ncia, red flags e sugira exames/condutas. Use [revisar] para d√∫vidas.`
      };

      abortOrg = await streamTo(org, '/api/organizar', payloadOrg);
      abortAna = await streamTo(analise, '/api/analisar', payloadAna);
    }

    btnExecutar.addEventListener('click', processar);
    btnPausar.addEventListener('click', pausar);
    btnLimpar.addEventListener('click', () => { entrada.value = ''; limpar(); });

    entrada.addEventListener('input', () => {
      if (!cbAuto.checked) return;
      clearTimeout(timer);
      timer = setTimeout(processar, 1000);
    });
  </script>
</body>

</html>

